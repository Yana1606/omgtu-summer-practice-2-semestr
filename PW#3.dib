#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №1. Знакомство с потоками.

**Цель:** Познакомиться с возможностями класса System.Thread платформы .NET Framework.

**Результаты:** После выполнения работы Вы сможете:
1. Запускать длительные операции в отдельном потоке.
2. Завершать поток.
3. Дожидаться завершения выполнения потока. 


**Материалы для самостоятельного изучения**.
1. [Основы управления потоками](https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-basics)
2. [Использование потоков](https://learn.microsoft.com/en-us/dotnet/standard/threading/using-threads-and-threading)
3. [Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier)
4. [Interlocked операции](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0)

## Задание.
Реализовать вычисление определенного интеграла методом трапеции в несколько потоков.

Отрезок, на котором происходит вычисление, разбивается на отрезки по количеству потоков. Для каждого отрезка значение 
интеграла считается в отдельном потоке, после завершения вычисоения полученный рельтаты суммирутся.

**Указание**.
1. Для суммирования результатов удобно воспользоваться разделяемой переменной, к которой будут прибалятся результаты вычисления прямо в самом потоке. Для синхронизации операций сложения лучше всего восользоваться [Interlocked операцией](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0).
2. Основная функция долна дождаться завершения всех потоков, которые вычисляют значение на отрезках, прежде чем возвратить результат. Для этого удобнее всего использовать Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier).

#!csharp

using System;
using System.Threading.Tasks;
using System.Threading;

class DefiniteIntegral
{
    private static double customResult;
    private static Barrier barrier;


    public static double Solve(double a, double b, Func<double, double> function, double step, int threadsNumber)
    {
        double customSteps = step / 10;
        customResult = 0.0;
        barrier = new Barrier(threadsNumber);

        Task[] tasks = new Task[threadsNumber];
        for (int i = 0; i < threadsNumber; i++)
        {
            int threadIndex = i;
            tasks[i] = Task.Run(() =>
            {
                double localResult = CalculatePartialIntegral(a, b, function, customSteps, threadsNumber, threadIndex);
                Add(ref customResult, localResult);
                barrier.SignalAndWait();
            });
        }

        Task.WaitAll(tasks);

        return customResult;
    }

    private static double CalculatePartialIntegral(double a, double b, Func<double, double> function, double step, int threadsNumber, int threadIndex)
    {
        double locA = a + threadIndex * (b - a) / threadsNumber;
        double locB = locA + (b - a) / threadsNumber;
        double customLocalResult = 0.0;

        for (double x = locA; x < locB; x += step)
        {
            customLocalResult += (function(x) + function(x + step)) * step / 2.0;
        }

        if (locB > b - step)
        {
            customLocalResult += (function(b - step) + function(b)) * step / 2.0;
        }

        return customLocalResult;
    }

    private static void Add(ref double loc1, double value)
    {
        double newCurrVariable;
        double currVariable = loc1;
        do
        {
            newCurrVariable = currVariable + value;
        }
        while (Interlocked.CompareExchange(ref loc1, newCurrVariable, currVariable) != currVariable);
    }
}

#!csharp

#r "nuget: xunit, 2.8.1"

using Xunit;

var X = (double x) => x;
var SIN = (double x) => Math.Sin(x);

Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, X, 1e-4, 2), 1e-4);

Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, SIN, 1e-5, 8), 1e-4);

Assert.Equal(50, DefiniteIntegral.Solve(0, 10, X, 1e-6, 8), 1e-5);
