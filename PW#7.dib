#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №7.Реализация потока обработки команад.

**Цель:** Реализовать основу для многопоточного сервера приложений.

**Результаты:** После выполнения работы Вы сможете:
1. Обрабатывать множество операций в несколько потоков.
2. Останавливать потоки по запросу извне.

## Задание.
Пусть операция задана интерфейсом

#!csharp

using System;
using System.Collections.Concurrent;
using System.Threading;

public interface ICommand
{
    void Execute();
}

public class ServerThread
{
    private readonly ConcurrentQueue<ICommand> commandQueue = new ConcurrentQueue<ICommand>();
    private Thread runThread;
    private volatile bool isRunning;
    private bool isStopping = false;

    public Thread RunThread => runThread;

    public ServerThread()
    {
        isRunning = true;
        runThread = new Thread(Run);
        runThread.Start();
    }

    // Метод для добавления команды в очередь
    public void AddCommand(ICommand command)
    {
        if (isRunning)
        {
            commandQueue.Enqueue(command);
        }
    }

    // Основной метод, выполняющий команды из очереди
    private void Run()
    {
        try
        {
            while (isRunning || !commandQueue.IsEmpty)
            {
                if (commandQueue.TryDequeue(out ICommand command))
                {
                    try
                    {
                        command.Execute();
                    }
                    catch (Exception ex)
                    {
                        // Более подробная обработка исключений
                        Console.WriteLine($"Исключение, обнаруженное во время выполнение программы: {ex.Message}");
                    }
                }
            }
        }
        finally
        {
            
        }
    }

    // Метод для остановки сервера с обработкой оставшихся команд
    private void Stop(bool hardStop)
    {
        isStopping = true;
        isRunning = false;

        // Обработка оставшихся команд
        while (!commandQueue.IsEmpty)
        {
            if (commandQueue.TryDequeue(out ICommand command))
            {
                try
                {
                    command.Execute();
                }
                catch (Exception ex)
                {
                    // Обработка исключений
                    Console.WriteLine($"Исключение, обнаруженное во время выполнение программы: {ex.Message}");

                }
            }
        }

        commandQueue.Clear();

        if (hardStop)
        {
            // Прерывание потока
            runThread.Interrupt();
        }
    }
}

#!csharp

public abstract class Command
{
    public abstract void Execute();
}

public class TestCommand : Command
{
    private string _name;
    private bool _throwException;

    public TestCommand(string name, bool throwException = false)
    {
        _name = name;
        _throwException = throwException;
    }

    public override void Execute()
    {
        Console.WriteLine($"Выполнение команды: {_name}");
        if (_throwException)
        {
            throw new Exception("Ошибка выполнения команды");
        }
    }
}

// Команда "Мягкая остановка"
public class SoftStop : Command
{
    private ServerThread _serverThread;

    public SoftStop(ServerThread serverThread)
    {
        _serverThread = serverThread;
    }

    public override void Execute()
    {
        _serverThread.Stop();
    }
}

// Команда "Жёсткая остановка"
public class HardStop : Command
{
    private ServerThread _serverThread;

    public HardStop(ServerThread serverThread)
    {
        _serverThread = serverThread;
    }

    public override void Execute()
    {
        _serverThread.HardStop();
    }
}

// Серверный поток
public class ServerThread
{
    private List<Command> _commands = new List<Command>();

    // Добавление команды в список
    public void AddCommand(Command command)
    {
        _commands.Add(command);
    }

    // Запуск серверного потока
    public void Start()
    {
        foreach (var command in _commands)
        {
            try
            {
                command.Execute();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Произошло исключение: {ex.Message}");
            }
        }
    }

    // Мягкая остановка
    public void Stop()
    {
        Console.WriteLine("Остановка сервера (мягкая)");
    }

    // Жёсткая остановка
    public void HardStop()
    {
        Console.WriteLine("Остановка сервера (жёсткая)");
    }
}

// Создание списка тестов
var tests = new List<(string name, Func<ServerThread> setup)>
{
    ("Обычная работа сервера", () =>
    {
        var serverThread = new ServerThread();
        serverThread.AddCommand(new TestCommand("Команда 1"));
        serverThread.AddCommand(new TestCommand("Команда 2"));
        serverThread.AddCommand(new TestCommand("Команда 3"));
        serverThread.AddCommand(new SoftStop(serverThread));
        return serverThread;
    }),
    ("Жёсткая остановка сервера", () =>
    {
        var serverThread = new ServerThread();
        serverThread.AddCommand(new TestCommand("Команда 1"));
        serverThread.AddCommand(new TestCommand("Команда 2"));
        serverThread.AddCommand(new HardStop(serverThread));
        return serverThread;
    }),
    ("Исключение при выполнении команды", () =>
    {
        var serverThread = new ServerThread();
        serverThread.AddCommand(new TestCommand("Команда 1"));
        serverThread.AddCommand(new TestCommand("Команда 2"));
        serverThread.AddCommand(new TestCommand("Команда 3 с исключением", true)); // Исключение здесь
        serverThread.AddCommand(new SoftStop(serverThread));
        return serverThread;
    }),
};

// Запуск тестов
foreach (var (name, setup) in tests)
{
    Console.WriteLine($"Тест: {name}");
    var serverThread = setup();
    serverThread.Start();
    Console.WriteLine("Тест завершён.");
    Console.WriteLine();
}

Console.Read();

#!markdown

Классы, наследующие интерйес ICommand будем называть **Командами.**

Реализовать класс ServerThread и команды по hard и soft завершению потока. 

ServerThread может менять свое поведение для обработки следующей Команды.
Исключение, выброшенное из Команды, перехватывается и передается вместе с самой Командой в ExceptionHandler (см. ЛР №5) Примечание. Наличие реализованного обработчика исключений не обязательно для выполнения данной задачи. 

Команда HardStop приводит к немедленной остановке потока, несмотря на, что в очереди потока есть еще Команды.
Команда  SoftStop останавливает поток, когда в очереди потока закончатся все Команды.

Команды HardStop и SoftStop успешно выполняются только в потоке, который они должны остановить, в противном случае выбрасывают исключение.
Отсутствие Команд в очереди потока не должно требовать значительных затрат процессорного времени. Значительными считаются затраты, которые зависят от времени простоя потока.

Написать проверку, которая гарантирует правильное выполнение команд HardStop и SoftStop.
